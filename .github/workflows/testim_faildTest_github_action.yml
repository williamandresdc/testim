name: Crear Bug en qTest cuando falla el job

on: [push]

jobs:
  run-testimio-cli:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v4
      - run: npm install -g @testim/testim-cli
      - run: testim --token "onlfP7MDMyaYPkpYBoRjqhmv8lIbTRTqAdwJrYf4u4Hkyd383N" --project "nKGi7CBJylaVVp7nSVJ3" --grid "Testim-Grid" --suite "FaildTest" --timeout 300000

  create-qtest-defect:
    # Este job solo se ejecutará después de que "run-testimio-cli" haya terminado.
    needs: run-testimio-cli
    # Esta condición crucial asegura que solo se ejecute si el job anterior falla.
    if: failure()
    runs-on: ubuntu-latest

    steps:
      - name: Create qTest Defect
        id: create_defect_step
        env:
          QTEST_TOKEN: ${{ secrets.QTEST_TOKEN }}
          QTEST_WEBHOOK_DISCORD: ${{ secrets.QTEST_WEBHOOK_DISCORD }}
          QTEST_PROJECT_ID: '21672'
          QTEST_SUMMARY_FIELD_ID: '2097336'
          QTEST_DESCRIPTION_FIELD_ID: '2097339'
          GITHUB_REPO: ${{ github.repository }}
          GITHUB_RUN_ID: ${{ github.run_id }}
          GITHUB_COMMIT_SHA: ${{ github.sha }}
        run: |
          QTEST_URL="https://williamdiaz.qtestnet.com/api/v3/projects/${QTEST_PROJECT_ID}/defects"
          SUMMARY="Error en pipeline ${GITHUB_RUN_ID}"
          DESCRIPTION="El commit ${GITHUB_COMMIT_SHA} falló. Revisa: https://github.com/${GITHUB_REPO}/actions/runs/${GITHUB_RUN_ID}"

          # Realiza la primera solicitud y almacena la respuesta completa en una variable
          RESPONSE=$(curl --silent --location "$QTEST_URL" \
            --header "Authorization: $QTEST_TOKEN" \
            --header "Content-Type: application/json" \
            --data-raw "{
              \"properties\": [
                {
                  \"field_id\": ${QTEST_SUMMARY_FIELD_ID},
                  \"field_name\": \"Summary\",
                  \"field_value\": \"${SUMMARY}\"
                },
                {
                  \"field_id\": ${QTEST_DESCRIPTION_FIELD_ID},
                  \"field_name\": \"Description\",
                  \"field_value\": \"${DESCRIPTION}\"
                }
              ]
            }")

          # Asegúrate de que la primera solicitud fue exitosa antes de continuar
          if [ -z "$RESPONSE" ]; then
            echo "Error: La primera solicitud curl no devolvió ninguna respuesta."
            exit 1
          fi
          
          echo "Respuesta de la primera solicitud: $RESPONSE"

          ESCAPED_RESPONSE=$(echo "$RESPONSE" | jq -c '.')
          echo "QTEST_RESPONSE_DATA=$ESCAPED_RESPONSE" >> $GITHUB_OUTPUT
          
      - name: Notificar al webhook
        env:
            QTEST_WEBHOOK_DISCORD: ${{ secrets.QTEST_WEBHOOK_DISCORD }}
        # Este paso depende de la salida del paso anterior
        run: |
          echo "Respuesta del primer paso:"
          echo "${{ steps.create_defect_step.outputs.QTEST_RESPONSE_DATA }}"

          # Asignar correctamente usando una variable de entorno de GitHub
          QTEST_RESPONSE_JSON='${{ steps.create_defect_step.outputs.QTEST_RESPONSE_DATA }}'

          echo "Enviando a webhook: $QTEST_RESPONSE_JSON"

          curl -X POST "$QTEST_WEBHOOK_DISCORD" \
            --header 'Content-Type: application/json' \
            --data "$QTEST_RESPONSE_JSON"
